(defparameter *line-spacing* (* (1+ *font-height*) 40))
(defparameter *act-font* :present)
(defparameter *act-colour* #x10)
(defparameter *print-transcript* nil)
(defparameter *echo-print* nil)

(defun update-vicky ()
  (let ((buf (monitor-buffer))) ;need to abstract out the memory, ditch cl-6502
    (loop for i from 0 to +char-memory-length+ do
	 (setf (aref buf (+ i *char-memory-address*)) #x79))
    (setmem-copy buf)))

(defun typeset ()
    
  (zp-w :font)

  ;;TODO the namespaces here are a bit arbitrary, might want to clean it up

  ;;This is the chunk of code that peels off symbols from the string
  ;;characters are passed to the :typeset chunk for rendering. Words
  ;;are split into characters and then individually passed. EOL and EOS
  ;;are handled here too.
  (with-namespace :typeset-cs
    (alias :sym :D3)
    (alias :tmp-raster :A4)
    (alias :str :huffman-ptr)
    (label :typeset-cs nil)
    (LDA 0)
    (STA.AB :scroll-on-newline "At this entry point we do not scroll the message")
    (STA.ZP '(:typeset . :shift))
    (STA.ZP '(:typeset . :prev-width))
    (label :typeset-cs-continue nil) ;;but with a new string
    (cpy16.zp '(:typeset . :raster) :tmp-raster)
    (sta16.zp :general-letters :huffman-pop-table)
    (LDA 1)
    (STA.ZP :huffman-bits)
    (label :next)
    (JSR :huffman-next)
    (LDA.ABX :hi-char-offsets)
    (CMP *word-lo-page*)
    (BGE :is-word)
    (JSR :emit)
    (JMP :next)
    (label :is-word)
    (dc "Hi address contains length-2 in low three bits")
    (TAY)
    (AND.IMM #x7)
    (CLC)
    (ADC #x2)
    (STA.AB (1+ (resolve :word-offset)))
    (TYA)
    (LSR)
    (LSR)
    (LSR)
    (dc "Now we have a page offset to the dictionary, 1 based")
    (CLC)
    (ADC (1- (hi :dictionary)))
    (STA.AB (hi-add (1+ (resolve :word-ptr))))
    (LDA.ABX :lo-char-offsets)
    (STA.AB (lo-add (1+ (resolve :word-ptr))))
    (label :next-character)
    (label :word-offset)
    (LDY 0 "Offset")
    (DEC.AB (1+ (resolve :word-offset)))
    (BMI :next)
    (label :word-ptr)
    ;;The end of string marker does not have to appear in the dictionary
    ;;it could be omitted and the length reduced by one
    (LDA.ABY 0 "Word address -1");;self modified parameter
    (TAX)
    (JSR :emit)
    (JMP :next-character)

    ;;emit a single character
    ;;handling eos and newlines as appropriate
    
    (label :emit)
    ;;in the debugger, gather up the characters so they can be printed
    (let ((string nil))
      (dbg (if (= x (nil->0 (eos-index)))
	       (progn
		 (push (coerce (nreverse string) 'string) *print-transcript*)
		 (when *echo-print*
		   (princ (car *print-transcript*))
		   (terpri))
		 (setf string nil))
	       (push (car (nth x *huffman-table*)) string))))
    (CPX (nil->0 (eos-index)))
    (BEQ :done)
    (CPX (nil->0 (eol-index)))
    (BEQ :newline)
    (LDA.ABX :lo-char-offsets)
    (CLC)
    (ADC.ZP (lo-add :font))
    (STA.ZP (lo-add '(:typeset . :char)))
    (LDA.ABX :hi-char-offsets)
    (ADC.ZP (hi-add :font))
    (STA.ZP (hi-add '(:typeset . :char)))
    (JMP :typeset "Emit a single character and return")

    (label :newline)
    
    (LDA 0)
    (STA.ZP '(:typeset . :shift))
    (STA.ZP '(:typeset . :prev-width))
    (label+1 :scroll-on-newline)
    (ORA 0 "If zero, scroll, otherwise, go to next row")
    (BEQ :next-line)
    (dc "Go back to the beginning of the line")
    (dc "then scroll up, so we are writing on the same row")
    (cpy16.zp :tmp-raster '(:typeset . :raster))
    (JMP :scroll)
    
    (label :next-line)
    (dc "Move the raster to the next row")
    (LDA 0)
    (STA.ZP '(:typeset . :shift))
    (STA.ZP '(:typeset . :prev-width))
    (SEC)
    (LDA (lo (1- (* 40 (1+ *font-height*)))))
    (ADC.ZP (lo-add :tmp-raster))
    (STA.ZP (lo-add :tmp-raster))
    (STA.ZP (lo-add '(:typeset . :raster)))
    (LDA (hi (1- (* 40 (1+ *font-height*)))))
    (ADC.ZP (hi-add :tmp-raster))
    (STA.ZP (hi-add :tmp-raster))
    (STA.ZP (hi-add '(:typeset . :raster)))
    (RTS)

    (label :done)
    (dc "Directly return to caller")
    (PLA)
    (PLA)
    (RTS))
  
  (label :typeset)
  
  (with-namespace :typeset
    (alias :char :A2)
    (alias :raster :A3)
    (alias :shift :D1)
    (alias :prev-width :D2)
    
    (zp-b :left-shift)
    
    (LDX 0 "Ensure we can use X indexed addressing later")
    (LDA.ZP :prev-width)
    (BEQ :start)
    (dc "Prior to this shift, bit 6 set if previous char admits to the right")
    (ASL "Now that flag is in bit 7")
    (dc "Bit 7 set iff prev char admits to right and current char admits to left")    
    (AND.IZX :char)
    (EOR #x80)
    (ASL)
    (dc "Now the carry is set iff there is no kerning between the two characters")
    (LDA.ZP :prev-width)
    (AND.IMM #xf)
    (ADC.ZP :shift)
    (CMP 8)
    (BCC :not-wrapped)
    (dc "There is a case where we will have a char of width 9")
    (dc "this means we need to advance an extra byte")
    (dc "Doing this compare clears the carry when we don't")
    (CMP 16)
    (AND.IMM #x7)
    (STA.ZP :shift)
    (sbc16.zp (1- (* 40 (1- *font-height*))) :raster)
    (JMP :start)
    (label :not-wrapped)
    (dc "Move the raster back up, and left 1 byte")
    (STA.ZP :shift)
    (sub16.zp (1+ (* 40 (1- *font-height*))) :raster)
    (label :start)
    (LDA.ZP :shift)
    (dc "Self modify branch to perform correct shift")
    (STA.AB (1+ (resolve :shift-left)))
    (CLC)
    (EOR #xFF)
    (ADC 9)
    (STA.AB (1+ (resolve :shift-right)))
    (LDY *font-height* (format nil "~a pixel character height" *font-height*))
    (LDX 0)
    (BEQ :go)
    (label :next)
    (CLC)
    (dc "Move the raster to the next line")
    (LDA.ZP (lo-add :raster))
    (ADC 39 "40 for screen, -1")
    (STA.ZP (lo-add :raster))
    (BCC :go)
    (INC.ZP (hi-add :raster))
    (label :go)
    ;;  X needs to be 0 throughout
    (LDA.IZY :char "Get the bit pattern")
    (dc "Just jump to the next screen byte and blat it")
    (dc "if the bit pattern is empty")
    (BEQ :skip-clear)
    (dc "Shift the bit pattern across by the offset")
    (dc "and OR it with the screen")
    (label :shift-right)
    (BNE 0)
    (LSR)
    (LSR)
    (LSR)
    (LSR)
    (LSR)
    (LSR)
    (LSR)
    (LSR)
    (ORA.IZX :raster)
    (STA.IZX :raster)
    (dc "Now shift the same character byte left by 8-offset")
    (dc "Get the bit pattern again")
    (LDA.IZY :char)
    (label :shift-left)
    (BNE 0)
    ;;todo splitting :go into two functions depending on size of shift might save 20ms
    (ASL)
    (ASL)
    (ASL)
    (ASL)
    (ASL)
    (ASL)
    (ASL)
    (ASL)
    (BEQ :skip-clear)
    ;;clauses are duplicated for performance
    (dc "Clear the next byte")
    (inc16.zp :raster)
    (STA.IZX :raster)
    (DEY)
    (BNE :next)
    (LDA.IZY :char)
    (STA.ZP :prev-width)
    (RTS)
    (label :skip-clear)
    (dc "Don't clear the next byte")
    ;;side effect is overexuberant clearing which can paste over
    ;;the following line if we ignore this
    ;;I thought to replace this by setting the carry and calling into
    ;;next, but it didn't work
    (inc16.zp :raster)
    (DEY)
    (BNE :next)
    (dc "Now, the first byte of the character data holds the")
    (dc "width of the character. Store it, so we can use it")
    (dc "before we draw the next character")
    (LDA.IZY :char)
    (STA.ZP :prev-width)
    (RTS)))

(defun live-row (i)
  (+ 3 (* (+ i 13) *line-height*)))

(defun print-message ()

  "Install a 6502 print message function which can be called by either
   JSR :print-message-inline DW string-address
   or JSR :print-message X=(lo) A=(hi)"

  (label :scroll)
  (dc "Scroll one line up, erasing the fourth row (i.e. last but one)")
  (call-memcpy (scradd (live-row 1) 0)
	       (scradd (live-row 0) 0)
	       (* 4 +screen-width-bytes+ *line-height*))
  (call-memset 0 (scradd (live-row 3) 0)
	       (* 1 +screen-width-bytes+ *line-height*))
  (RTS)
  
  (label :print-message-inline)

  (with-namespace :print-message
    
    (JSR :deref-w)
    
    (label :print-message nil)

    (STX.ZP (lo-add '(:typeset-cs . :str)))
    (STA.ZP (hi-add '(:typeset-cs . :str)))
    
    (JSR :scroll)
    
    (LDA (lo (scradd (live-row 3) 0)))
    (STA.ZP (lo-add '(:typeset . :raster)))
    (STA.ZP (lo-add '(:typeset-cs . :tmp-raster)))
    (LDA (hi (scradd (live-row 3) 0)))
    (STA.ZP (hi-add '(:typeset . :raster)))
    (STA.ZP (hi-add '(:typeset-cs . :tmp-raster)))
    ;;first render the prompt
    (sta16.zp :prompt '(:typeset . :char))
    (LDA 0)
    (STA.ZP '(:typeset . :prev-width))
    (STA.ZP '(:typeset . :shift))
    (JSR :typeset)
    ;;put the raster back where it started
    (cpy16.zp '(:typeset-cs . :tmp-raster) '(:typeset . :raster))
    ;;now draw the text with and offset of 5 pixels which we
    ;;all know is the width of the prompt
    (LDA 0)
    (STA.ZP '(:typeset . :prev-width))
    (LDA 5)
    (STA.ZP '(:typeset . :shift))
    (STA.AB '(:typeset-cs . :scroll-on-newline) "Scroll on newline")
    (JMP :typeset-cs-continue)))

