;; Actions and handler that should be common across
;; games, e.g. INVENTORY, EXAMINE etc

;; TODO When there is a duplicate object, one of which is in the
;; inventory, there is no point in saying "Be more specific"
;; we should only find the objects which are in the inventory

(defvar *what-enabled* t "What is a testing thing")

(defparameter *be-more-specific* "You'll have to be more specific...")
(defparameter *unknown-word* "I don't know that word.")
(defparameter *do-not-have* "You don't have that.")
(defparameter *cant-do-that* "You can't do that to it!")
(defparameter *already-have* "You already have that.")
(defparameter *cant-take-that* "You can't take that.")
(defparameter *you-took-it* "You took it!")
(defparameter *you-dropped-it* "You dropped it!")
(defparameter *dont-see-that* "I don't see that.")
(defparameter *you-take-a-look* "You take a look around and see...")
(defparameter *you-have* "You have...")
(defparameter *nothing* "Nothing.")
(defparameter *it-is-nothing* "Nothing.")
(defparameter *dont-understand* "I don't understand.")
(defparameter *cant-go-that-way* "You can't go that way.")
(defparameter *something* "Something something...")
(defparameter *not-here* "That isn't here!")
  
(defun generic-generic-handlers ()
 
  (with-location :generic
    (defword :INVENTORY :I)

    (when *what-enabled*
      (custom-action '(WHAT)
	;;Print the name or description of the IT object
	(with-namespace :what
	  (dc "What is IT?")
	  (LDY.AB '(:object-table . :it))
	  ;;(dbg (format t "OBJECT=~a~%" y))
	  (BNE :something)
	  (respond-raw *it-is-nothing*)
	  (RTS)
	  (label :something)
	  (dc "Now print the object name, if it has one")
	  (LDX.ABY (1- (resolve '(:object-table . :name-lo))))
	  (LDA.ABY (1- (resolve '(:object-table . :name-hi))))
	  (BNE :print)
	  (respond-raw *something*)
	  (RTS)
	  (label :print)
	  (JMP :print-message))))
    
    (custom-action '(LOOK)
      (with-namespace :look
	(respond-raw *you-take-a-look*)
	(LDA *object-show*)
	(dc "Do NOT show objects that do not want to be listed")
	(STA.AB '(:inventory . :object-property-mask))
	(LDA.ZP :current-place)
	(JMP '(:inventory . :scan-objects))))

    (custom-action '(INVENTORY)
      (with-namespace :inventory
	(respond-raw *you-have*)
	(LDA 255)
	(dc "For inventory, show everything")
	(STA.AB :object-property-mask)
	(LDA 1 "Inventory is Place 1")
	(label :scan-objects)
	(dc "Reset matching object count to 0")
	(LDX 0)
	(STX.AB :object-count)
	(LDY (hash-table-count *object-name->data*))
	(label :next-object)
	(dc "List the object in the place in A")
	(dc "Look in one-based object places table")
	(PHA)
	(CMP.ABY (1- (resolve '(:object-table . :places))))
	(BNE :object-not-here)
	(dc "Get object properties")
	(LDA.ABY (1- (resolve '(:object-table . :properties))))
	(dc "Apply a mask to filter out undesirables, self modifying.")
	(label+1 :object-property-mask)
	(AND.IMM 0)
	(BEQ :object-not-here)
	(dc "Save object index")
        (STY.AB '(:object-table . :it))
	(dc "Now print the object name")
	(LDA.ABY (1- (resolve '(:object-table . :name-hi))))
	(LDX.ABY (1- (resolve '(:object-table . :name-lo))))
	(JSR :print-message)
	(dc "Restore Y and A, i.e. IT and object-count")
	(LDY.AB '(:object-table . :it))
	(INC.AB :object-count)
	(label :object-not-here)
	(PLA)
	(DEY)
	(BNE :next-object)
	(LDX.AB :object-count)
	(BNE :not-empty)
	(respond-raw *nothing*)
	(label :not-empty)
	(CPX 1)
	(BEQ :unique)
	(LDA 0 "Clear It")
	(STA.AB '(:object-table . :it))
	(label :unique)
	(RTS)
	(dc "Temporary counter when scanning objects")
	(db :object-count 0)))

    ;; Note, generic verbs are implemented in 6502 rather than VM

    (label :check-object-here)
    (dc "Check the object is here. Return to gp if not.")
    (dc "It is a bug to reach here")
    (dc "as the object parser shouldn't have found the object")
    (dc "in the first place. It is unlikely custom verbs will")
    (LDA.ABY (1- (resolve '(:object-table . :places))))
    (CMP 1)
    (BEQ :ok)
    (CMP.ZP :current-place)
    (BEQ :ok)
    (respond-raw *not-here*)
    (dbg (error "Attempting to do something to object ~a which isn't here." y))
    (PLA)
    (PLA)
    (label :ok)
    (RTS)
    
    (with-namespace :take
      (label :doit)
      (dc "Do we already have this?")
      (LDA 1)
      (CMP.ABY (1- (resolve '(:object-table . :places))))
      (BEQ :already-have)
      (JSR '(:generic . :check-object-here))
      (label :can-take-it?)
      (LDA *object-take*)
      (AND.ABY (1- (resolve '(:object-table . :properties))))
      (BNE :take-it)
      (respond-raw *cant-take-that*)
      (RTS)
      (label :take-it)
      (dc "Set the place to inventory")
      (STA.ABY (1- (resolve '(:object-table . :places))))
      (respond-raw *you-took-it*)
      (RTS)
      (label :already-have)
      (respond-raw *already-have*)
      (RTS)
      (label :not-here)
      (respond-raw *not-here*)
      (RTS))

    (with-namespace :drop
      (label :doit)
      (dc "Check we have this object about our person")
      (LDA 1)
      (CMP.ABY (1- (resolve '(:object-table . :places))))
      (BNE :do-not-have)
      (label :drop-it)
      (dc "Now set its place to the current place")
      (LDA.ZP :current-place)
      (STA.ABY (1- (resolve '(:object-table . :places))))
      (respond-raw *you-dropped-it*)
      (RTS)
      (label :do-not-have)
      (respond-raw *do-not-have*)
      (RTS))

    (with-namespace :examine
      (label :doit)
      (JSR '(:generic . :check-object-here))
      (dc "Print the description")
      (LDA.ABY (1- (resolve '(:object-table . :description-hi))))
      (LDX.ABY (1- (resolve '(:object-table . :description-lo))))
      (JMP :print-message))

    (with-namespace :verb-handler
      ;; make a vtable for a generic object. each generic
      ;; verb needs an entry label called :doit
      (label :generic-vtable)
      (flet ((entry (verb ns);
	       ;;TODO Make defword idempotent and remove this check
	       (unless (gethash (symbol-name verb) *word->meaning*)
		 (defword verb))
	       (dc (format nil "~a" verb))
	       (db nil (word-id verb))
	       (dw nil (cons ns :doit))))
	(entry 'EXAMINE :examine)
	(entry 'TAKE :take)
	(entry 'DROP :drop)
	(dc "End marker")
	(db nil 0)))

    (when (> (hash-table-count *exit-words*) 0)
      (apply #'db :exit-words (mapcar #'word-id (hash-keys *exit-words*))))
    
    (custom-action '(? ? ? ?)
      (with-namespace :verb-handler
	(alias :vtable :A0)
	(alias :object-id :D0)
	(LDA.AB :word-count)
	(CMP 2)
	(BLT :not-verb-object)	
	(LDA.AB '(:parser . :words))
	(BNE :valid-ish-verb)
	(respond-raw *unknown-word*)
	(RTS)
	(label :unknown-exit)
	(respond-raw *cant-go-that-way*)
	(RTS)
	(label :not-verb-object)
	(CMP 1)
	(BNE :dont-understand)
	(dc "Is this an unhandled 'exit' word? They need a different error.")
	(LDA.AB '(:parser . :words))
	(LDY (hash-table-count *exit-words*))
	(label :check-for-exit-word)
	(CMP.ABY (1- (resolve :exit-words)))
	(BEQ :unknown-exit)
	(DEY)
	(BNE :check-for-exit-word)
	(label :dont-understand)
	(respond-raw *dont-understand*)
	(RTS)
	(label :valid-ish-verb)
	(JSR :parse-objects)
	(BCS :duplicate-found)
	(LDY.AB :object1)
	(BEQ :not-found)
	(STY.ZP :object-id)
	(dc "Look for the verb handler for an object")
	(LDX 2 "Two goes, object specific then generic")
	(LDA.ABY (1- (resolve '(:object-table . :verb-hi))))
	(BEQ :nope "No handlers are on the zero page, so this means not set")
	(STA.ZP (hi-add :vtable))
	(LDA.ABY (1- (resolve '(:object-table . :verb-lo))))
	(STA.ZP (lo-add :vtable))
	(dc "Now look for the entry that corresponds to our verb")
	(label :scan-vtable)
	(LDY 0)
	(label :next)
	(LDA.IZY :vtable)
	(BEQ :nope)
	(CMP.AB '(:parser . :words))
	(BEQ :found)
	;;TODO EARLY RETURN IF THE VERBS ARE SORTED
	;;BY WORD ID WE CAN QUIT EARLY IF WE GO PAST IT
	(dc "Skip to next, three bytes per entry")
	(INY)
	(INY)
	(INY)
	(BNE :next)
	(label :nope)
	(dc "Once more, with the generic vtable?")
	(DEX)
	(BEQ :definitely-nope)
	(label :generic-only)
	(dc "We can jump into this point if we set X to 1")
	(dbg (assert (= x 1))) 
	(LDA (lo :generic-vtable))
	(STA.ZP (lo-add :vtable))
	(LDA (hi :generic-vtable))
	(STA.ZP (hi-add :vtable))
	(BNE :scan-vtable)
	(label :definitely-nope)
	(respond-raw *cant-do-that*)
	(RTS)
	(label :duplicate-found)
	(respond-raw *be-more-specific*)
	(RTS)	
	(label :found)
	(dc "Call the VM with the address of the handler")
	(INY)
	(LDA.IZY :vtable)
	(STA.ZP (lo-add :vm-pc))
	(INY)
	(LDA.IZY :vtable)
	(STA.ZP (hi-add :vm-pc))
        (TXA)
	(CMP 1 "Generic handler?")
	(BNE :vm-handler)
	(LDY.ZP :object-id "Generic handler might quite like to know what object it is")
	(JMP.IND :vm-pc "Generic handler is 6502")
	(label :vm-handler)
	(JMP :vm-go "Execute VM code and return to grandparent")
	(label :not-found)
	(respond-raw *dont-see-that*)
	(RTS)))))

(defun test-render-input ()
  (label :test-render-input)
  (with-namespace :test-render-input
    ;;this simulates the user having already entered the text on the bottom
    ;;row and pressing return. The existing text in the 4 lines above is
    ;;scrolled up and the text is posted on line 4 (not five, which remains empty)
    (JSR :scroll)
    (sta16.zp (scradd (live-row 3) 0) '(:typeset . :raster))
    (alias :pos :D4)
    (alias :str :A4)
    (label :typeset-is nil)
    (LDY 0)
    (STY.ZP '(:typeset . :shift))
    (STY.ZP '(:typeset . :prev-width))
    (sta16.zp '(:parser . :input) :str)
    (label :next)
    (STY.ZP :pos)
    (LDA.IZY :str)
    (BNE :not-space)
    (LDA (lo '(:present . #\ )))
    (STA.ZP (lo-add '(:typeset . :char)))
    (LDA (hi '(:present . #\ )))
    (STA.ZP (hi-add '(:typeset . :char)))
    (JMP :emit)
    (label :not-space)
    (TAX)
    (LDA.ABX (1- (resolve ':1ch-lo)))
    (CLC)
    (dc "Add the offset of the font")
    (ADC.ZP (lo-add :font))
    (STA.ZP (lo-add '(:typeset . :char)))	
    (LDA.ABX (1- (resolve ':1ch-hi)))
    (ADC.ZP (hi-add :font))
    (STA.ZP (hi-add '(:typeset . :char)))
    (label :emit)
    (JSR :typeset)
    (LDY.ZP :pos)
    (INY)
    (CPY *max-input-length*)
    (BNE :next)
    (RTS)

    ;; We shouldn't need this table really, once the compressed
    ;; string table contains all the letters.
    
    (let ((lo (list :1ch-lo))
	  (hi (list :1ch-hi)))
      (loop for c across "ABCDEFGHIJKLMNOPQRSTUVWXYZ" do
	   (let ((offset (- (resolve (cons :present c))
			    (resolve '(:font . :present)))))
	     (push (lo offset) lo)
	     (push (hi offset) hi)))
      (apply #'db (nreverse lo))
      (apply #'db (nreverse hi)))))

;;TODO Move this into slime-interface.lisp

(defun enter-input (str &key (break-on 'brk) (print t))
  ;;really need to make better 6502 emulator to avoid need
  ;;for copying the buffer
  (let ((buffer (cl-6502:get-range 0)))
    ;;we must clear the buffer for new input
    (loop for i from 0 to *max-input-length* do
	 (setf (aref buffer (+ i (resolve '(:parser . :input)))) 0))
    
    (loop for c across str
       for i from 0 to *max-input-length* do       
	 (setf (aref buffer (+ i (resolve '(:parser . :input))))
	       (to-alphabet-pos c)))
    (setf (cl-6502:get-range 0) buffer))
  (monitor-setpc :test-input)
  (monitor-run :break-on break-on :print (and print
					      (eq break-on 'brk)))
  (when print
    (unless (eq break-on 'brk)
      (monitor-go)))
  (setmem-copy (monitor-buffer))
  (when print
    (dump-state-base64)))

(defun gogogo (&key (echo t))
  (princ "q to quit")
  (terpri)
  (tagbody
   :top
     (let ((line (read-line)))
       (if (equalp line "q")
	   (return-from gogogo))
       (let ((*echo-print* echo))
	 (enter-input line :print nil)
	 (go :top)))))

(defun restore-game (str &key (break-on 'brk) (print t))
  (restore-state-base64 str)
  (monitor-setpc :restore-game)
  (monitor-run :break-on break-on :print print)
  (setmem-copy (monitor-buffer))
  (enter-input "LOOK" :print print)
  (values))
  
