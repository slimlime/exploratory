(defun ninsert (o l)
  (let ((p nil))
    (do ()
	((or (null l)
	     (< (second o) (second (car l)))))
      (setf p l)
      (setf l (cdr l)))
    (if (consp p) (setf (cdr p) (cons o l)) nil)))

;;doesn't work for odd number of entries!

(defun huffman1 (symbols)
  (let ((q (sort (copy-list symbols) #'< :key #'second))
	(node nil))
    (do ()
	((null q))
      (setf node (let ((n1 (pop q))
		       (n2 (pop q)))
		   (list (list (first n1) (first n2))
			 (+ (second n1) (second n2)))))
      (ninsert node q))
    node))

(defun huffman (symbols)
  (let ((tree (car (huffman1 symbols)))
	(patterns nil))
    (labels ((doit (tr depth byte)
	       (if (listp tr)
		   (progn
		     (when (> (length tr) 0)
		       (doit (first tr) (1+ depth) (ash byte 1)))
		     (when (> (length tr) 1)
		       (doit (second tr) (1+ depth) (1+ (ash byte 1)))))
		   (push (list tr depth byte (ash byte (- 16 depth))) patterns))))	  
      (doit tree 0 0))
    (stable-sort (sort patterns #'< :key #'fourth) #'< :key #'second))))

(defun print-huffman (pattern)
  (let ((i -1))
    (dolist (p pattern)
      (format t "~3d ~a len:~3a bits:~16,'0b ~a~%"
	      (incf i)
	      (first p)
	      (second p)
	      (fourth p)
	      (fourth p)))))
