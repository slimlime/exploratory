(defun ninsert (o l)
  (let ((p nil))
    (do ()
	((or (null l)
	     (< (second o) (second (car l)))))
      (setf p l)
      (setf l (cdr l)))
    (if (consp p) (setf (cdr p) (cons o l)) nil)))

;;doesn't work for odd number of entries!

(defun huffman1 (symbols)
  (let ((q (sort (copy-list symbols) #'< :key #'second))
	(node nil))
    (do ()
	((null q))
      (setf node (let ((n1 (pop q))
		       (n2 (pop q)))
		   (list (list (first n1) (first n2))
			 (+ (second n1) (second n2)))))
      (ninsert node q))
    node))

(defun huffman (symbols)
  (let ((tree (car (huffman1 symbols)))
	(patterns nil))
    (labels ((doit (tr depth byte)
	       (if (stringp tr)
		   (push (list tr depth byte (ash byte (- 16 depth))) patterns)
		   (progn
		     (when (> (length tr) 0)
		       (doit (first tr) (1+ depth) (ash byte 1)))
		     (when (> (length tr) 1)
		       (doit (second tr) (1+ depth) (1+ (ash byte 1)))))
		   )))	  
      (doit tree 0 0))
    (sort patterns #'< :key #'fourth)))

(defun print-huffman (pattern)
  (dolist (p pattern)
    (format t "~a len:~3a bits:~16,'0b~%"
	    (first p)
	    (second p)
	    (fourth p))))
